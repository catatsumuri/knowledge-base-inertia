---
title: フォーム
---

import { ClientSpecific } from "/snippets/client-specific.jsx"
import { ReactSpecific } from "/snippets/react-specific.jsx"
import { SvelteSpecific } from "/snippets/svelte-specific.jsx"
import { VueSpecific } from "/snippets/vue-specific.jsx"

Inertia は、フォームを構築するための 2 つの主要な方法を提供します。`<Form>` コンポーネントと `useForm` ヘルパーです。どちらもサーバーサイドフレームワークのバリデーションと統合されており、フルページのリロードなしでフォーム送信を処理します。

## Form コンポーネント

Inertia は、従来の HTML フォームとよく似た挙動をする `<Form>` コンポーネントを提供しますが、内部では Inertia を使用してフルページのリロードを回避します。これは、Inertia でフォームを始める最も簡単な方法です。

<CodeGroup>

```vue Vue icon="vuejs"
<script setup>
import { Form } from '@inertiajs/vue3'
</script>

<template>
    <Form action="/users" method="post">
        <input type="text" name="name" />
        <input type="email" name="email" />
        <button type="submit">Create User</button>
    </Form>
</template>
```

```jsx React icon="react"
import { Form } from '@inertiajs/react'

export default () => (
    <Form action="/users" method="post">
        <input type="text" name="name" />
        <input type="email" name="email" />
        <button type="submit">Create User</button>
    </Form>
)
```

```svelte Svelte icon="s"
<script>
    import { Form } from '@inertiajs/svelte'
</script>

<Form action="/users" method="post">
    <input type="text" name="name" />
    <input type="email" name="email" />
    <button type="submit">Create User</button>
</Form>
```

</CodeGroup>

従来の HTML フォームと同様に、入力フィールドに Vueなら`v-model`、Reactなら`onChange` ハンドラー、Svelteなら`bind:`を追加する必要はありません。各入力に `name` 属性 、Reactなら（該当する場合は）`defaultValue` を指定するだけで、`Form` コンポーネントがデータ送信を処理してくれます。

このコンポーネントは、ネストされたデータ構造、ファイルアップロード、ドット区切りのキー記法にも対応しています。

<CodeGroup>

```vue Vue icon="vuejs"
<template>
    <Form action="/reports" method="post">
        <input type="text" name="name" />
        <textarea name="report[description]"></textarea>
        <input type="text" name="report[tags][]" />
        <input type="file" name="documents" multiple />
        <button type="submit">レポートを作成</button>
    </Form>
</template>
```

```jsx React icon="react"
<Form action="/reports" method="post">
    <input type="text" name="name" />
    <textarea name="report[description]"></textarea>
    <input type="text" name="report[tags][]" />
    <input type="file" name="documents" multiple />
    <button type="submit">レポートを作成</button>
</Form>
```

```svelte Svelte icon="s"
<Form action="/reports" method="post">
    <input type="text" name="name" />
    <textarea name="report[description]"></textarea>
    <input type="text" name="report[tags][]" />
    <input type="file" name="documents" multiple />
    <button type="submit">レポートを作成</button>
</Form>
```

</CodeGroup>

送信前にフォームデータを変更するために、`transform` プロパティを渡すことができます。これは追加のフィールドを注入したり、既存のデータを変換したりするのに便利ですが、hidden input を使う方法でも可能です。

<CodeGroup>

```vue Vue icon="vuejs"
<template>
    <Form
        action="/posts"
        method="post"
        :transform="data => ({ ...data, user_id: 123 })"
    >
        <input type="text" name="title" />
        <button type="submit">投稿を作成</button>
    </Form>
</template>
```

```jsx React icon="react"
<Form
    action="/posts"
    method="post"
    transform={data => ({ ...data, user_id: 123 })}
>
    <input type="text" name="title" />
    <button type="submit">投稿を作成</button>
</Form>
```

```svelte Svelte icon="s"
<Form
    action="/posts"
    method="post"
    transform={data => ({ ...data, user_id: 123 })}
>
    <input type="text" name="title" />
    <button type="submit">投稿を作成</button>
</Form>
```

</CodeGroup>


### Wayfinder

[Wayfinder](https://github.com/laravel/wayfinder) を使用する場合、生成されたオブジェクトをそのまま `action` プロパティに渡すことができます。Form コンポーネントは、Wayfinder オブジェクトから HTTP メソッドと URL を自動的に推論します。

<CodeGroup>

```vue Vue icon="vuejs"
<script setup>
import { Form } from '@inertiajs/vue3'
import { store } from 'App/Http/Controllers/UserController'
</script>

<template>
    <Form :action="store()">
        <input type="text" name="name" />
        <input type="email" name="email" />
        <button type="submit">Create User</button>
    </Form>
</template>
```

```jsx React icon="react"
import { Form } from '@inertiajs/react'
import { store } from 'App/Http/Controllers/UserController'

export default () => (
    <Form action={store()}>
        <input type="text" name="name" />
        <input type="email" name="email" />
        <button type="submit">Create User</button>
    </Form>
)
```

```svelte Svelte icon="s"
<script>
    import { Form } from '@inertiajs/svelte'
    import { store } from 'App/Http/Controllers/UserController'
</script>

<Form action={store()}>
    <input type="text" name="name" />
    <input type="email" name="email" />
    <button type="submit">Create User</button>
</Form>
```

</CodeGroup>


### デフォルト値

<ClientSpecific>
標準の HTML 属性を使用して、フォーム入力のデフォルト値を設定できます。テキスト入力とテキストエリアには <ReactSpecific>`defaultValue`</ReactSpecific><VueSpecific>`defaultValue`</VueSpecific><SvelteSpecific>`value`</SvelteSpecific> を使用し、チェックボックスとラジオボタンには <ReactSpecific>`defaultChecked`</ReactSpecific><VueSpecific>`defaultChecked`</VueSpecific><SvelteSpecific>`checked`</SvelteSpecific> を使用します。
</ClientSpecific>

<CodeGroup>

```vue Vue icon="vuejs"
<template>
    <Form action="/users" method="post">
        <input type="text" name="name" defaultValue="John Doe" />

        <select name="country">
            <option value="us">United States</option>
            <option value="ca">Canada</option>
            <option value="uk" selected>United Kingdom</option>
        </select>

        <input type="checkbox" name="subscribe" value="yes" defaultChecked />

        <button type="submit">Submit</button>
    </Form>
</template>
```

```jsx React icon="react"
<Form action="/users" method="post">
    <input type="text" name="name" defaultValue="John Doe" />

    <select name="country" defaultValue="uk">
        <option value="us">United States</option>
        <option value="ca">Canada</option>
        <option value="uk">United Kingdom</option>
    </select>

    <input type="checkbox" name="subscribe" value="yes" defaultChecked />

    <button type="submit">Submit</button>
</Form>
```

```svelte Svelte icon="s"
<Form action="/users" method="post">
    <input type="text" name="name" value="John Doe" />

    <select name="country" value="uk">
        <option value="us">United States</option>
        <option value="ca">Canada</option>
        <option value="uk">United Kingdom</option>
    </select>

    <input type="checkbox" name="subscribe" value="yes" checked />

    <button type="submit">Submit</button>
</Form>
```

</CodeGroup>


### チェックボックス入力

チェックボックスを扱う際には、`value="1"` のように明示的な `value` 属性を追加したくなる場合があります。`value` 属性がない場合、チェックされたチェックボックスは `"on"` として送信されますが、これは一部のサーバーサイドのバリデーションルールでは適切な boolean 値として認識されないことがあります。

### スロットプロパティ

`<Form>` コンポーネントは、デフォルトスロットを通じてリアクティブな状態やヘルパーメソッドを公開します。これにより、フォームの処理状態、エラー、ユーティリティ関数にアクセスできます。

<CodeGroup>

```vue Vue icon="vuejs"
<template>
    <Form
        action="/users"
        method="post"
        #default="{
            errors,
            hasErrors,
            processing,
            progress,
            wasSuccessful,
            recentlySuccessful,
            setError,
            clearErrors,
            resetAndClearErrors,
            defaults,
            isDirty,
            reset,
            submit,
        }"
    >
        <input type="text" name="name" />

        <div v-if="errors.name">
            {{ errors.name }}
        </div>

        <button type="submit" :disabled="processing">
            {{ processing ? 'Creating...' : 'Create User' }}
        </button>

        <div v-if="wasSuccessful">User created successfully!</div>
    </Form>
</template>
```

```jsx React icon="react"
<Form action="/users" method="post">
    {({
        errors,
        hasErrors,
        processing,
        progress,
        wasSuccessful,
        recentlySuccessful,
        setError,
        clearErrors,
        resetAndClearErrors,
        defaults,
        isDirty,
        reset,
        submit,
    }) => (
        <input type="text" name="name" />

        {errors.name && <div>{errors.name}</div>}

        <button type="submit" disabled={processing}>
            {processing ? 'Creating...' : 'Create User'}
        </button>

        {wasSuccessful && <div>User created successfully!</div>}
    )}
</Form>
```

```svelte Svelte 4 icon="s"
<Form
    action="/users"
    method="post"
    let:errors
    let:hasErrors
    let:processing
    let:progress
    let:wasSuccessful
    let:recentlySuccessful
    let:setError
    let:clearErrors
    let:resetAndClearErrors
    let:defaults
    let:isDirty
    let:reset
    let:submit
>
    <input type="text" name="name" />

    {#if errors.name}
        <div>{errors.name}</div>
    {/if}

    <button type="submit" disabled={processing}>
        {processing ? 'Creating...' : 'Create User'}
    </button>

    {#if wasSuccessful}
        <div>User created successfully!</div>
    {/if}
</Form>
```

```svelte Svelte 5 icon="s"
<Form action="/users" method="post">
    {#snippet children({
        errors,
        hasErrors,
        processing,
        progress,
        wasSuccessful,
        recentlySuccessful,
        setError,
        clearErrors,
        resetAndClearErrors,
        defaults,
        isDirty,
        reset,
        submit,
    })}
        <input type="text" name="name" />

        {#if errors.name}
            <div>{errors.name}</div>
        {/if}

        <button type="submit" disabled={processing}>
            {processing ? 'Creating...' : 'Create User'}
        </button>

        {#if wasSuccessful}
            <div>User created successfully!</div>
        {/if}
    {/snippet}
</Form>
```

</CodeGroup>

`defaults` メソッドを使用すると、現在のフィールド値に合わせてフォームのデフォルト値を更新できます。これを呼び出すと、その後の `reset()` 呼び出しではフィールドがこれらの新しいデフォルト値に復元され、`isDirty` プロパティは更新後のデフォルトからの変更を追跡します。`useForm` とは異なり、このメソッドは引数を受け取らず、常に現在のすべてのフォーム値を使用します。

`errors` オブジェクトはネストされたフィールドに対してドット記法を使用するため、複雑なフォーム構造のバリデーションメッセージを表示できます。

<CodeGroup>

```vue Vue icon="vuejs"
<Form action="/users" method="post" #default="{ errors }">
    <input type="text" name="user.name" />
    <div v-if="errors['user.name']">{{ errors['user.name'] }}</div>
</Form>
```

```jsx React icon="react"
<Form action="/users" method="post">
    {({ errors }) => (
        <input type="text" name="user.name" />
        {errors['user.name'] && <div>{errors['user.name']}</div>}
    )}
</Form>
```

```svelte Svelte 4 icon="s"
<Form action="/users" method="post" let:errors>
    <input type="text" name="user.name" />
    {#if errors['user.name']}
        <div>{errors['user.name']}</div>
    {/if}
</Form>
```

```svelte Svelte 5 icon="s"
<Form action="/users" method="post">
    {#snippet children({ errors })}
        <input type="text" name="user.name" />
        {#if errors['user.name']}
            <div>{errors['user.name']}</div>
        {/if}
    {/snippet}
</Form>
```

</CodeGroup>

### Props とオプション

`action` と `method` に加えて、`<Form>` コンポーネントはいくつかの props を受け取ります。その多くは、Inertia の [visit オプション](/v2/the-basics/manual-visits) で利用可能なオプションと同一です。

<CodeGroup>

```vue Vue icon="vuejs"
<template>
    <Form
        action="/profile"
        method="put"
        error-bag="profile"
        query-string-array-format="indices"
        :headers="{ 'X-Custom-Header': 'value' }"
        :show-progress="false"
        :transform="data => ({ ...data, timestamp: Date.now() })"
        :invalidate-cache-tags="['users', 'dashboard']"
        disable-while-processing
        :options="{
            preserveScroll: true,
            preserveState: true,
            preserveUrl: true,
            replace: true,
            only: ['users', 'flash'],
            except: ['secret'],
            reset: ['page'],
        }"
    >
        <input type="text" name="name" />
        <button type="submit">Update</button>
    </Form>
</template>
```

```jsx React icon="react"
<Form
    action="/profile"
    method="put"
    errorBag="profile"
    queryStringArrayFormat="indices"
    headers={{ 'X-Custom-Header': 'value' }}
    showProgress={false}
    transform={data => ({ ...data, timestamp: Date.now() })}
    invalidateCacheTags={['users', 'dashboard']}
    disableWhileProcessing
    options={{
        preserveScroll: true,
        preserveState: true,
        preserveUrl: true,
        replace: true,
        only: ['users', 'flash'],
        except: ['secret'],
        reset: ['page'],
    }}
>
    <input type="text" name="name" />
    <button type="submit">Update</button>
</Form>
```

```svelte Svelte icon="s"
<Form
    action="/profile"
    method="put"
    errorBag="profile"
    queryStringArrayFormat="indices"
    headers={{ 'X-Custom-Header': 'value' }}
    showProgress={false}
    transform={data => ({ ...data, timestamp: Date.now() })}
    invalidateCacheTags={['users', 'dashboard']}
    disableWhileProcessing
    options={{
        preserveScroll: true,
        preserveState: true,
        preserveUrl: true,
        replace: true,
        only: ['users', 'flash'],
        except: ['secret'],
        reset: ['page'],
    }}
>
    <input type="text" name="name" />
    <button type="submit">Update</button>
</Form>
```

</CodeGroup>

一部の props は、混乱を避けるためにトップレベルではなく、意図的に `options` の下にまとめられています。たとえば、`only`、`except`、`reset` は *部分的なリロード* に関連するものであり、*部分的な送信* には関係しません。一般的なルールとして、トップレベルの props はフォーム送信そのものに関するもので、`options` はその後の visit を Inertia がどのように処理するかを制御します。

<ClientSpecific>
<ReactSpecific>`disableWhileProcessing`</ReactSpecific><SvelteSpecific>`disableWhileProcessing`</SvelteSpecific><VueSpecific>`disable-while-processing`</VueSpecific>prop を設定すると、フォームの処理中に `Form` コンポーネントは HTML の `form` タグに `inert` 属性を追加し、ユーザー操作を防止します。
</ClientSpecific>

処理中のフォームをスタイリングするには、次の方法で `inert` 状態のフォームを対象にできます。

<CodeGroup>

```jsx Tailwind 4
<Form
    action="/profile"
    method="put"
    disableWhileProcessing
    className="inert:opacity-50 inert:pointer-events-none"
>
    {/* フォームフィールドをここに */}
</Form>
```

```css CSS
form[inert] {
    opacity: 0.5;
    pointer-events: none;
}
```

</CodeGroup>


### イベント

`<Form>` コンポーネントは、フォーム送信時に標準の訪問 [イベント](/v2/advanced/events) をすべて発火します。

<CodeGroup>

```vue Vue icon="vuejs"
<template>
    <Form
        action="/users"
        method="post"
        @before="handleBefore"
        @start="handleStart"
        @progress="handleProgress"
        @success="handleSuccess"
        @error="handleError"
        @finish="handleFinish"
        @cancel="handleCancel"
        @cancelToken="handleCancelToken"
    >
        <input type="text" name="name" />
        <button type="submit">Create User</button>
    </Form>
</template>
```

```jsx React icon="react"
<Form
    action="/users"
    method="post"
    onCancelToken={handleCancelToken}
    onBefore={handleBefore}
    onStart={handleStart}
    onProgress={handleProgress}
    onCancel={handleCancel}
    onSuccess={handleSuccess}
    onError={handleError}
    onFinish={handleFinish}
>
    <input type="text" name="name" />
    <button type="submit">Create User</button>
</Form>
```

```svelte Svelte 4 icon="s"
<Form
    action="/users"
    method="post"
    on:cancelToken={handleCancelToken}
    on:before={handleBefore}
    on:start={handleStart}
    on:progress={handleProgress}
    on:cancel={handleCancel}
    on:success={handleSuccess}
    on:error={handleError}
    on:finish={handleFinish}
>
    <input type="text" name="name" />
    <button type="submit">Create User</button>
</Form>
```

```svelte Svelte 5 icon="s"
<Form
    action="/users"
    method="post"
    onCancelToken={handleCancelToken}
    onBefore={handleBefore}
    onStart={handleStart}
    onProgress={handleProgress}
    onCancel={handleCancel}
    onSuccess={handleSuccess}
    onError={handleError}
    onFinish={handleFinish}
>
    <input type="text" name="name" />
    <button type="submit">Create User</button>
</Form>
```

</CodeGroup>


### フォームのリセット

`Form` コンポーネントには、送信後にフォームをリセットできるいくつかの属性が用意されています。

`resetOnSuccess` は、送信が成功した後にフォームをリセットするために使用できます。

<CodeGroup>

```vue Vue icon="vuejs"
<template>
    <!-- 成功時にフォーム全体をリセット -->
    <Form action="/users" method="post" resetOnSuccess>
        <input type="text" name="name" />
        <input type="email" name="email" />
        <button type="submit">送信</button>
    </Form>

    <!-- 成功時に特定のフィールドのみをリセット -->
    <Form action="/users" method="post" :resetOnSuccess="['name']">
        <input type="text" name="name" />
        <input type="email" name="email" />
        <button type="submit">送信</button>
    </Form>
</template>
```

```jsx React icon="react"
// 成功時にフォーム全体をリセット
<Form action="/users" method="post" resetOnSuccess>
    <input type="text" name="name" />
    <input type="email" name="email" />
    <button type="submit">送信</button>
</Form>

// 成功時に特定のフィールドのみをリセット
<Form action="/users" method="post" resetOnSuccess={['name']}>
    <input type="text" name="name" />
    <input type="email" name="email" />
    <button type="submit">送信</button>
</Form>
```

```svelte Svelte icon="s"
<!-- 成功時にフォーム全体をリセット -->
<Form action="/users" method="post" resetOnSuccess>
    <input type="text" name="name" />
    <input type="email" name="email" />
    <button type="submit">送信</button>
</Form>

<!-- 成功時に特定のフィールドのみをリセット -->
<Form action="/users" method="post" resetOnSuccess={['name']}>
    <input type="text" name="name" />
    <input type="email" name="email" />
    <button type="submit">送信</button>
</Form>
```

</CodeGroup>

`resetOnError` は、エラー発生後にフォームをリセットするために使用できます。

<CodeGroup>

```vue Vue icon="vuejs"
<template>
    <!-- エラー時にフォーム全体をリセット -->
    <Form action="/users" method="post" resetOnError>
        <input type="text" name="name" />
        <input type="email" name="email" />
        <button type="submit">送信</button>
    </Form>

    <!-- エラー時に特定のフィールドのみをリセット -->
    <Form action="/users" method="post" :resetOnError="['name']">
        <input type="text" name="name" />
        <input type="email" name="email" />
        <button type="submit">送信</button>
    </Form>
</template>
```

```jsx React icon="react"
// エラー時にフォーム全体をリセット
<Form action="/users" method="post" resetOnError>
    <input type="text" name="name" />
    <input type="email" name="email" />
    <button type="submit">送信</button>
</Form>

// エラー時に特定のフィールドのみをリセット
<Form action="/users" method="post" resetOnError={['name']}>
    <input type="text" name="name" />
    <input type="email" name="email" />
    <button type="submit">送信</button>
</Form>
```

```svelte Svelte icon="s"
<!-- エラー時にフォーム全体をリセット -->
<Form action="/users" method="post" resetOnError>
    <input type="text" name="name" />
    <input type="email" name="email" />
    <button type="submit">送信</button>
</Form>

<!-- エラー時に特定のフィールドのみをリセット -->
<Form action="/users" method="post" resetOnError={['name']}>
    <input type="text" name="name" />
    <input type="email" name="email" />
    <button type="submit">送信</button>
</Form>
```

</CodeGroup>


### 新しいデフォルト値の設定

`Form` コンポーネントは `setDefaultsOnSuccess` プロパティを提供しており、送信が成功した後に現在のフォームの値を新しいデフォルト値として設定できます。

<CodeGroup>

```vue Vue icon="vuejs"
<template>
    <Form action="/users" method="post" setDefaultsOnSuccess>
        <input type="text" name="name" />
        <input type="email" name="email" />
        <button type="submit">送信</button>
    </Form>
</template>
```

```jsx React icon="react"
<Form action="/users" method="post" setDefaultsOnSuccess>
    <input type="text" name="name" />
    <input type="email" name="email" />
    <button type="submit">送信</button>
</Form>
```

```svelte Svelte icon="s"
<Form action="/users" method="post" setDefaultsOnSuccess>
    <input type="text" name="name" />
    <input type="email" name="email" />
    <button type="submit">送信</button>
</Form>
```

</CodeGroup>

### ドット記法（Dotted Key Notation）

`<Form>` コンポーネントは、フラットな入力名からネストされたオブジェクトを作成するためにドット記法をサポートしています。これにより、フォームデータを便利に構造化できます。

<CodeGroup>

```vue Vue icon="vuejs"
<template>
    <Form action="/users" method="post">
        <input type="text" name="user.name" />
        <input type="text" name="user.skills[]" />
        <input type="text" name="address.street" />
        <button type="submit">送信</button>
    </Form>
</template>
```

```jsx React icon="react"
<Form action="/users" method="post">
    <input type="text" name="user.name" />
    <input type="text" name="user.skills[]" />
    <input type="text" name="address.street" />
    <button type="submit">送信</button>
</Form>
```

```svelte Svelte icon="s"
<Form action="/users" method="post">
    <input type="text" name="user.name" />
    <input type="text" name="user.skills[]" />
    <input type="text" name="address.street" />
    <button type="submit">送信</button>
</Form>
```

</CodeGroup>

上記の例では、以下のデータ構造が生成されます。

```json
{
    "user": {
        "name": "John Doe",
        "skills": ["JavaScript"]
    },
    "address": {
        "street": "123 Main St"
    }
}
```

もしフィールド名に文字通りのドットを使いたい場合（ネストの区切りとしてではなく）、バックスラッシュでエスケープできます。

<CodeGroup>

```vue Vue icon="vuejs"
<template>
    <Form action="/config" method="post">
        <input type="text" name="app\.name" />
        <input type="text" name="settings.theme\.mode" />
        <button type="submit">保存</button>
    </Form>
</template>
```

```jsx React icon="react"
<Form action="/config" method="post">
    <input type="text" name="app\.name" />
    <input type="text" name="settings.theme\.mode" />
    <button type="submit">保存</button>
</Form>
```

```svelte Svelte icon="s"
<Form action="/config" method="post">
    <input type="text" name="app\.name" />
    <input type="text" name="settings.theme\.mode" />
    <button type="submit">保存</button>
</Form>
```

</CodeGroup>

上記の例では、以下のデータ構造が生成されます。

```json
{
    "app.name": "My Application",
    "settings": {
        "theme.mode": "dark"
    }
}
```

### プログラムによるアクセス

`refs` を使うことで、フォームのメソッドにプログラムからアクセスできます。これは、フォームの外部からフォームのアクションをトリガーする必要がある場合に、[スロットプロップ](#slot-props) の代替手段として利用できます。

<CodeGroup>

```vue Vue icon="vuejs"
<script setup>
import { ref } from 'vue'
import { Form } from '@inertiajs/vue3'

const formRef = ref()

const handleSubmit = () => {
    formRef.value.submit()
}
</script>

<template>
    <Form ref="formRef" action="/users" method="post">
        <input type="text" name="name" />
        <button type="submit">送信</button>
    </Form>

    <button @click="handleSubmit">プログラムから送信</button>
</template>
```

```jsx React icon="react"
import { useRef } from 'react'
import { Form } from '@inertiajs/react'

export default function CreateUser() {
    const formRef = useRef()

    const handleSubmit = () => {
        formRef.current.submit()
    }

    return (
        <Form ref={formRef} action="/users" method="post">
            <input type="text" name="name" />
            <button type="submit">送信</button>
        </Form>

        <button onClick={handleSubmit}>プログラムから送信</button>
    )
}
```

```svelte Svelte icon="s"
<script>
import { Form } from '@inertiajs/svelte'

let formRef

function handleSubmit() {
    formRef.submit()
}
</script>

<Form bind:this={formRef} action="/users" method="post">
    <input type="text" name="name" />
    <button type="submit">送信</button>
</Form>

<button on:click={handleSubmit}>プログラムから送信</button>
```

</CodeGroup>

React と Vue では、refs を使うとフォームのすべてのメソッドとリアクティブな状態にアクセスできます。Svelte では refs はメソッドのみを提供するため、`isDirty` や `errors` のようなリアクティブな状態は [スロットプロップ](#slot-props) でアクセスする必要があります。

---

### Precognition

<Badge>v2.3+</Badge>

`<Form>` コンポーネントは [Laravel Precognition](https://laravel.com/docs/precognition) に対応しており、クライアント側でサーバーのバリデーションルールを重複させることなく、リアルタイムでフォームの検証が可能です。

<Note>
Precognition を使用するにはサーバー側の対応が必要です。Laravel を使っている場合は [Laravel Precognition ドキュメント](https://laravel.com/docs/precognition) を参照してください。他のフレームワークでは、[プロトコルページ](/v2/core-concepts/the-protocol#request-headers) を確認してください。
</Note>

サーバーが設定されたら、`validate()` にフィールド名を渡すことでそのフィールドを検証できます。`invalid()` ヘルパーはフィールドにバリデーションエラーがあるかを確認し、`validating` はリクエストが進行中かどうかを示します。

<CodeGroup>

```vue Vue icon="vuejs"
<template>
    <Form action="/users" method="post" #default="{ errors, invalid, validate, validating }">
        <label for="name">名前:</label>
        <input id="name" name="name" @change="validate('name')" />
        <p v-if="invalid('name')">{{ errors.name }}</p>

        <label for="email">メール:</label>
        <input id="email" name="email" @change="validate('email')" />
        <p v-if="invalid('email')">{{ errors.email }}</p>

        <p v-if="validating">検証中...</p>

        <button type="submit">ユーザー作成</button>
    </Form>
</template>
```

```jsx React icon="react"
<Form action="/users" method="post">
    {({ errors, invalid, validate, validating }) => (
        <>
            <label htmlFor="name">名前:</label>
            <input id="name" name="name" onChange={() => validate('name')} />
            {invalid('name') && <p>{errors.name}</p>}

            <label htmlFor="email">メール:</label>
            <input id="email" name="email" onChange={() => validate('email')} />
            {invalid('email') && <p>{errors.email}</p>}

            {validating && <p>検証中...</p>}

            <button type="submit">ユーザー作成</button>
        </>
    )}
</Form>
```

```svelte Svelte 4 icon="s"
<Form
    action="/users"
    method="post"
    let:errors
    let:invalid
    let:validate
    let:validating
>
    <label for="name">名前:</label>
    <input id="name" name="name" on:change={() => validate('name')} />
    {#if invalid('name')}
        <p>{errors.name}</p>
    {/if}

    <label for="email">メール:</label>
    <input id="email" name="email" on:change={() => validate('email')} />
    {#if invalid('email')}
        <p>{errors.email}</p>
    {/if}

    {#if validating}
        <p>検証中...</p>
    {/if}

    <button type="submit">ユーザー作成</button>
</Form>
```

```svelte Svelte 5 icon="s"
<Form action="/users" method="post">
    {#snippet children({ errors, invalid, validate, validating })}
        <label for="name">名前:</label>
        <input id="name" name="name" onchange={() => validate('name')} />
        {#if invalid('name')}
            <p>{errors.name}</p>
        {/if}

        <label for="email">メール:</label>
        <input id="email" name="email" onchange={() => validate('email')} />
        {#if invalid('email')}
            <p>{errors.email}</p>
        {/if}

        {#if validating}
            <p>検証中...</p>
        {/if}

        <button type="submit">ユーザー作成</button>
    {/snippet}
</Form>
```

</CodeGroup>

`valid()` ヘルパーを使うことで、フィールドがバリデーションに成功したかどうかも確認できます。

<CodeGroup>

```vue Vue icon="vuejs"
<Form action="/users" method="post" #default="{ errors, invalid, valid, validate }">
    <input name="email" @change="validate('email')" />
    <p v-if="valid('email')">有効なメールアドレスです</p>
    <p v-if="invalid('email')">{{ errors.email }}</p>
</Form>
```

```jsx React icon="react"
<Form action="/users" method="post">
    {({ errors, invalid, valid, validate }) => (
        <>
            <input name="email" onChange={() => validate('email')} />
            {valid('email') && <p>有効なメールアドレスです</p>}
            {invalid('email') && <p>{errors.email}</p>}
        </>
    )}
</Form>
```

```svelte Svelte 4 icon="s"
<Form action="/users" method="post" let:errors let:invalid let:valid let:validate>
    <input name="email" on:change={() => validate('email')} />
    {#if valid('email')}
        <p>有効なメールアドレスです</p>
    {/if}
    {#if invalid('email')}
        <p>{errors.email}</p>
    {/if}
</Form>
```

```svelte Svelte 5 icon="s"
<Form action="/users" method="post">
    {#snippet children({ errors, invalid, valid, validate })}
        <input name="email" onchange={() => validate('email')} />
        {#if valid('email')}
            <p>有効なメールアドレスです</p>
        {/if}
        {#if invalid('email')}
            <p>{errors.email}</p>
        {/if}
    {/snippet}
</Form>
```

</CodeGroup>

<Warning>
フォームの入力は、変更があってバリデーションレスポンスを受け取るまでは有効/無効として表示されません。
</Warning>

---

#### 複数フィールドの検証

`only` オプションを使うと、複数のフィールドを一度に検証できます。これはウィザード形式のフォームで、次のステップに進む前に表示されているすべてのフィールドを検証したい場合に便利です。

<CodeGroup>

```vue Vue icon="vuejs"
<Form action="/users" method="post" #default="{ validate }">
    <!-- ステップ1のフィールド -->
    <input name="name" />
    <input name="email" />

    <button
        type="button"
        @click="validate({
            only: ['name', 'email'],
            onSuccess: () => goToNextStep(),
            onValidationError: () => showErrors(),
        })"
    >
        次のステップ
    </button>
</Form>
```

```jsx React icon="react"
<Form action="/users" method="post">
    {({ validate }) => (
        <>
            {/* ステップ1のフィールド */}
            <input name="name" />
            <input name="email" />

            <button
                type="button"
                onClick={() => validate({
                    only: ['name', 'email'],
                    onSuccess: () => goToNextStep(),
                    onValidationError: () => showErrors(),
                })}
            >
                次のステップ
            </button>
        </>
    )}
</Form>
```

```svelte Svelte 4 icon="s"
<Form action="/users" method="post" let:validate>
    <!-- ステップ1のフィールド -->
    <input name="name" />
    <input name="email" />

    <button
        type="button"
        on:click={() => validate({
            only: ['name', 'email'],
            onSuccess: () => goToNextStep(),
            onValidationError: () => showErrors(),
        })}
    >
        次のステップ
    </button>
</Form>
```

```svelte Svelte 5 icon="s"
<Form action="/users" method="post">
    {#snippet children({ validate })}
        <!-- ステップ1のフィールド -->
        <input name="name" />
        <input name="email" />

        <button
            type="button"
            onclick={() => validate({
                only: ['name', 'email'],
                onSuccess: () => goToNextStep(),
                onValidationError: () => showErrors(),
            })}
        >
            次のステップ
        </button>
    {/snippet}
</Form>
```

</CodeGroup>

---

#### Touch と Validate

`touch()` メソッドは、バリデーションをトリガーせずにフィールドを「タッチ済み」とマークします。その後、引数なしで `validate()` を呼ぶことで、タッチ済みのすべてのフィールドを検証できます。

<CodeGroup>

```vue Vue icon="vuejs"
<Form action="/users" method="post" #default="{ validate, touch, touched }">
    <input name="name" @blur="touch('name')" />
    <input name="email" @blur="touch('email')" />
    <input name="phone" @blur="touch('phone')" />

    <button type="button" @click="validate()">タッチ済みフィールドを検証</button>

    <p v-if="touched('name')">名前がタッチされました</p>
</Form>
```

```jsx React icon="react"
<Form action="/users" method="post">
    {({ validate, touch, touched }) => (
        <>
            <input name="name" onBlur={() => touch('name')} />
            <input name="email" onBlur={() => touch('email')} />
            <input name="phone" onBlur={() => touch('phone')} />

            <button type="button" onClick={() => validate()}>タッチ済みフィールドを検証</button>

            {touched('name') && <p>名前がタッチされました</p>}
        </>
    )}
</Form>
```

```svelte Svelte 4 icon="s"
<Form action="/users" method="post" let:validate let:touch let:touched>
    <input name="name" on:blur={() => touch('name')} />
    <input name="email" on:blur={() => touch('email')} />
    <input name="phone" on:blur={() => touch('phone')} />

    <button type="button" on:click={() => validate()}>タッチ済みフィールドを検証</button>

    {#if touched('name')}
        <p>名前がタッチされました</p>
    {/if}
</Form>
```

```svelte Svelte 5 icon="s"
<Form action="/users" method="post">
    {#snippet children({ validate, touch, touched })}
        <input name="name" onblur={() => touch('name')} />
        <input name="email" onblur={() => touch('email')} />
        <input name="phone" onblur={() => touch('phone')} />

        <button type="button" onclick={() => validate()}>タッチ済みフィールドを検証</button>

        {#if touched('name')}
            <p>名前がタッチされました</p>
        {/if}
    {/snippet}
</Form>
```

</CodeGroup>

`touched()` ヘルパーは引数なしで呼び出すと、どのフィールドでもタッチ済みかを確認できます。`reset()` メソッドは、リセット対象のフィールドのタッチ状態をクリアします。

---

#### オプション

`validate()` メソッドは、コールバックや設定を含むオプションオブジェクトを受け取れます。

```js
validate('username', {
    onSuccess: () => {
        // バリデーション成功時の処理
    },
    onValidationError: (response) => {
        // バリデーション失敗時の処理 (422レスポンスなど)
    },
    onBeforeValidation: (newRequest, oldRequest) => {
        // falseを返すとバリデーションを防止
    },
    onFinish: () => {
        // バリデーション後に常に実行される
    },
})
```

オプションオブジェクトのみを渡して特定のフィールドを検証することも可能です。

```js
validate({
    only: ['name', 'email'],
    onSuccess: () => goToNextStep(),
})
```

バリデーションリクエストは自動的にデバウンスされます。最初のリクエストは即時に発火し、その後の変更はデフォルトで 1500ms デバウンスされます。このタイムアウトはカスタマイズ可能です。

<CodeGroup>

```vue Vue icon="vuejs"
<Form action="/users" method="post" :validation-timeout="500">
    <!-- ... -->
</Form>
```

```jsx React icon="react"
<Form action="/users" method="post" validationTimeout={500}>
    {/* ... */}
</Form>
```

```svelte Svelte icon="s"
<Form action="/users" method="post" validationTimeout={500}>
    <!-- ... -->
</Form>
```

</CodeGroup>

デフォルトでは、不要なアップロードを避けるためファイルはバリデーションリクエストに含まれません。ファイルサイズや MIME タイプの検証が必要な場合は、ファイルバリデーションを有効化できます。

<CodeGroup>

```vue Vue icon="vuejs"
<Form action="/users" method="post" validate-files>
    <!-- ... -->
</Form>
```

```jsx React icon="react"
<Form action="/users" method="post" validateFiles>
    {/* ... */}
</Form>
```

```svelte Svelte icon="s"
<Form action="/users" method="post" validateFiles>
    <!-- ... -->
</Form>
```

</CodeGroup>

デフォルトでは、バリデーションエラーは文字列（最初のエラーメッセージ）として簡略化されます。複数のバリデーションルールがあるフィールドのすべてのエラーを表示したい場合は、エラーを配列として保持できます。

<CodeGroup>

```vue Vue icon="vuejs"
<Form action="/users" method="post" with-all-errors>
    <!-- ... -->
</Form>
```

```jsx React icon="react"
<Form action="/users" method="post" withAllErrors>
    {/* ... */}
</Form>
```

```svelte Svelte icon="s"
<Form action="/users" method="post" withAllErrors>
    <!-- ... -->
</Form>
```

</CodeGroup>

## フォームヘルパー

`<Form>` コンポーネントに加えて、Inertia はプログラム的にフォームのデータや送信動作を制御したい場合に便利な `useForm` ヘルパーも提供しています。

<CodeGroup>

```vue Vue icon="vuejs"
<script setup>
import { useForm } from '@inertiajs/vue3'

const form = useForm({
    email: null,
    password: null,
    remember: false,
})
</script>

<template>
    <form @submit.prevent="form.post('/login')">
        <input type="text" v-model="form.email">
        <div v-if="form.errors.email">{{ form.errors.email }}</div>
        <input type="password" v-model="form.password">
        <div v-if="form.errors.password">{{ form.errors.password }}</div>
        <input type="checkbox" v-model="form.remember"> Remember Me
        <button type="submit" :disabled="form.processing">Login</button>
    </form>
</template>
```

```jsx React icon="react"
import { useForm } from '@inertiajs/react'

const { data, setData, post, processing, errors } = useForm({
    email: '',
    password: '',
    remember: false,
})

function submit(e) {
    e.preventDefault()
    post('/login')
}

return (
    <form onSubmit={submit}>
        <input type="text" value={data.email} onChange={e => setData('email', e.target.value)} />
        {errors.email && <div>{errors.email}</div>}
        <input type="password" value={data.password} onChange={e => setData('password', e.target.value)} />
        {errors.password && <div>{errors.password}</div>}
        <input type="checkbox" checked={data.remember} onChange={e => setData('remember', e.target.checked)} /> Remember Me
        <button type="submit" disabled={processing}>Login</button>
    </form>
)
```

```svelte Svelte 4 icon="s"
<script>
import { useForm } from '@inertiajs/svelte'

const form = useForm({
    email: null,
    password: null,
    remember: false,
})

function submit() {
    $form.post('/login')
}
</script>

<form on:submit|preventDefault={submit}>
    <input type="text" bind:value={$form.email} />
    {#if $form.errors.email}
        <div class="form-error">{$form.errors.email}</div>
    {/if}
    <input type="password" bind:value={$form.password} />
    {#if $form.errors.password}
        <div class="form-error">{$form.errors.password}</div>
    {/if}
    <input type="checkbox" bind:checked={$form.remember} /> Remember Me
    <button type="submit" disabled={$form.processing}>Submit</button>
</form>
```

```svelte Svelte 5 icon="s"
<script>
import { useForm } from '@inertiajs/svelte'

const form = useForm({
    email: null,
    password: null,
    remember: false,
})

function submit(e) {
    e.preventDefault()
    $form.post('/login')
}
</script>

<form onsubmit={submit}>
    <input type="text" bind:value={$form.email} />
    {#if $form.errors.email}
        <div class="form-error">{$form.errors.email}</div>
    {/if}
    <input type="password" bind:value={$form.password} />
    {#if $form.errors.password}
        <div class="form-error">{$form.errors.password}</div>
    {/if}
    <input type="checkbox" bind:checked={$form.remember} /> Remember Me
    <button type="submit" disabled={$form.processing}>Submit</button>
</form>
```

</CodeGroup>

フォームを送信するには、`get`、`post`、`put`、`patch`、`delete` メソッドを使用できます。

<CodeGroup>

```js Vue icon="vuejs"
form.submit(method, url, options)
form.get(url, options)
form.post(url, options)
form.put(url, options)
form.patch(url, options)
form.delete(url, options)
```

```js React icon="react"
const { submit, get, post, put, patch, delete: destroy } = useForm({ ... })

submit(method, url, options)
get(url, options)
post(url, options)
put(url, options)
patch(url, options)
destroy(url, options)
```

```js Svelte icon="s"
$form.submit(method, url, options)
$form.get(url, options)
$form.post(url, options)
$form.put(url, options)
$form.patch(url, options)
$form.delete(url, options)
```

</CodeGroup>

これらの送信メソッドは、`preserveState` や `preserveScroll`、イベントコールバックなど、通常の [visit オプション](/v2/the-basics/manual-visits) をサポートしています。例えば、`onSuccess` コールバックを使って、フォーム送信後に入力を初期状態にリセットすることが可能です。

<CodeGroup>

```js Vue icon="vuejs"
form.post('/profile', {
    preserveScroll: true,
    onSuccess: () => form.reset('password'),
})
```

```js React icon="react"
const { post, reset } = useForm({ ... })

post('/profile', {
    preserveScroll: true,
    onSuccess: () => reset('password'),
})
```

```js Svelte icon="s"
$form.post('/profile', {
    preserveScroll: true,
    onSuccess: () => $form.reset('password'),
})
```

</CodeGroup>

送信前にフォームデータを変換したい場合は、`transform()` メソッドを使うことができます。

<CodeGroup>

```js Vue icon="vuejs"
form
    .transform((data) => ({
        ...data,
        remember: data.remember ? 'on' : '',
    }))
    .post('/login')
```

```js React icon="react"
const { transform } = useForm({ ... })

transform((data) => ({
    ...data,
    remember: data.remember ? 'on' : '',
}))
```

```js Svelte icon="s"
$form
    .transform((data) => ({
        ...data,
        remember: data.remember ? 'on' : '',
    }))
    .post('/login')
```

</CodeGroup>

`processing` プロパティを使うと、フォームが現在送信中かどうかを追跡できます。これにより、送信ボタンを無効化して二重送信を防ぐことができます。

<CodeGroup>

```vue Vue icon="vuejs"
<button type="submit" :disabled="form.processing">Submit</button>
```

```jsx React icon="react"
const { processing } = useForm({ ... })

<button type="submit" disabled={processing}>Submit</button>
```

```svelte Svelte icon="s"
<button type="submit" disabled={$form.processing}>Submit</button>
```

</CodeGroup>

ファイルをアップロードしている場合、`progress` プロパティから現在の進捗を取得できるので、アップロード進行状況を簡単に表示できます。

<CodeGroup>

```vue Vue icon="vuejs"
<progress v-if="form.progress" :value="form.progress.percentage" max="100">
    {{ form.progress.percentage }}%
</progress>
```

```jsx React icon="react"
const { progress } = useForm({ ... })

{progress && (
    <progress value={progress.percentage} max="100">
        {progress.percentage}%
    </progress>
)}
```

```svelte Svelte icon="s"
{#if $form.progress}
    <progress value={$form.progress.percentage} max="100">
        {$form.progress.percentage}%
    </progress>
{/if}
```

</CodeGroup>

### フォームのエラー

バリデーションエラーは `errors` プロパティから取得できます。Laravel をバックエンドに使う Inertia アプリケーションでは、`ValidationException` がスローされると、フォームエラーは自動的にセットされます。例えば `$request->validate()` のようなケースです。

<CodeGroup>

```vue Vue icon="vuejs"
<div v-if="form.errors.email">{{ form.errors.email }}</div>
```

```jsx React icon="react"
const { errors } = useForm({ ... })

{errors.email && <div>{errors.email}</div>}
```

```svelte Svelte icon="s"
{#if $form.errors.email}
    <div>{$form.errors.email}</div>
{/if}
```

</CodeGroup>

フォームのバリデーションやエラーについて詳しくは、[バリデーションのドキュメント](/v2/the-basics/validation) を参照してください。

フォームにエラーがあるか確認するには `hasErrors` プロパティを使います。エラーをクリアする場合は `clearErrors()` メソッドを使用します。

<CodeGroup>

```js Vue icon="vuejs"
// 全てのエラーをクリア
form.clearErrors()

// 特定のフィールドのエラーをクリア
form.clearErrors('field', 'anotherfield')
```

```js React icon="react"
const { clearErrors } = useForm({ ... })

// 全てのエラーをクリア
clearErrors()

// 特定のフィールドのエラーをクリア
clearErrors('field', 'anotherfield')
```

```js Svelte icon="s"
// 全てのエラーをクリア
$form.clearErrors()

// 特定のフィールドのエラーをクリア
$form.clearErrors('field', 'anotherfield')
```

</CodeGroup>

クライアントサイドで独自にバリデーションを行う場合や手動で入力を検証する場合は、`setErrors()` メソッドでフォームに任意のエラーを設定できます。

<CodeGroup>

```js Vue icon="vuejs"
// 単一のエラーを設定
form.setError('field', 'エラーメッセージ');

// 複数のエラーを一度に設定
form.setError({
    foo: 'foo フィールド用のエラーメッセージ',
    bar: 'bar フィールド用の別のエラー'
});
```

```js React icon="react"
const { setError } = useForm({ ... })

// 単一のエラーを設定
setError('field', 'エラーメッセージ');

// 複数のエラーを一度に設定
setError({
    foo: 'foo フィールド用のエラーメッセージ',
    bar: 'bar フィールド用の別のエラー'
});
```

```js Svelte icon="s"
// 単一のエラーを設定
$form.setError('field', 'エラーメッセージ');

// 複数のエラーを一度に設定
$form.setError({
    foo: 'foo フィールド用のエラーメッセージ',
    bar: 'bar フィールド用の別のエラー'
});
```

</CodeGroup>

手動でエラーを設定しても、ページの props は変更されません。

フォームが正常に送信された場合、`wasSuccessful` プロパティは `true` になります。また、`recentlySuccessful` プロパティは送信成功後 2 秒間 `true` になり、一時的な成功メッセージを表示するのに利用できます。

`recentlySuccessful` の持続時間は、[アプリケーションデフォルト](/v2/installation/client-side-setup#configuring-defaults) で `form.recentlySuccessfulDuration` オプションを設定してカスタマイズ可能です。デフォルトは 2000 ミリ秒です。

### フォームのリセット

フォームの値を初期値に戻すには `reset()` メソッドを使用します。

<CodeGroup>

```js Vue icon="vuejs"
// フォーム全体をリセット
form.reset()

// 特定のフィールドだけリセット
form.reset('field', 'anotherfield')
```

```js React icon="react"
const { reset } = useForm({ ... })

// フォーム全体をリセット
reset()

// 特定のフィールドだけリセット
reset('field', 'anotherfield')
```

```js Svelte icon="s"
// フォーム全体をリセット
$form.reset()

// 特定のフィールドだけリセット
$form.reset('field', 'anotherfield')
```

</CodeGroup>

フォームを初期値に戻しつつバリデーションエラーも同時にクリアしたい場合は、`resetAndClearErrors()` メソッドを使うと、`reset()` と `clearErrors()` を一度に実行できます。

<CodeGroup>

```js Vue icon="vuejs"
// フォームをリセットして全てのエラーをクリア
form.resetAndClearErrors()

// 特定のフィールドをリセットしてそのエラーをクリア
form.resetAndClearErrors('field', 'anotherfield')
```

```js React icon="react"
const { resetAndClearErrors } = useForm({ ... })

// フォームをリセットして全てのエラーをクリア
resetAndClearErrors()

// 特定のフィールドをリセットしてそのエラーをクリア
resetAndClearErrors('field', 'anotherfield')
```

```js Svelte icon="s"
// フォームをリセットして全てのエラーをクリア
$form.resetAndClearErrors()

// 特定のフィールドをリセットしてそのエラーをクリア
$form.resetAndClearErrors('field', 'anotherfield')
```

</CodeGroup>

### 新しいデフォルト値の設定

フォームのデフォルト値が古くなった場合は、`defaults()` メソッドを使って更新できます。こうすることで、次回 `reset()` メソッドを呼び出した際にフォームは正しい値にリセットされます。

<CodeGroup>

```js Vue icon="vuejs"
// 現在のフォームの値を新しいデフォルト値として設定...
form.defaults()

// 単一フィールドのデフォルト値を更新...
form.defaults('email', 'updated-default@example.com')

// 複数フィールドのデフォルト値を更新...
form.defaults({
    name: 'Updated Example',
    email: 'updated-default@example.com',
})
```

```js React icon="react"
const { setDefaults } = useForm({ ... })

// 現在のフォームの値を新しいデフォルト値として設定...
setDefaults()

// 単一フィールドのデフォルト値を更新...
setDefaults('email', 'updated-default@example.com')

// 複数フィールドのデフォルト値を更新...
setDefaults({
    name: 'Updated Example',
    email: 'updated-default@example.com',
})
```

```js Svelte icon="s"
// 現在のフォームの値を新しいデフォルト値として設定...
$form.defaults()

// 単一フィールドのデフォルト値を更新...
$form.defaults('email', 'updated-default@example.com')

// 複数フィールドのデフォルト値を更新...
$form.defaults({
    name: 'Updated Example',
    email: 'updated-default@example.com',
})
```

</CodeGroup>

### フォームフィールドの変更追跡

フォームに変更があるか確認するには、`isDirty` プロパティを使用します。

<CodeGroup>

```vue Vue icon="vuejs"
<div v-if="form.isDirty">保存されていない変更があります。</div>
```

```jsx React icon="react"
const { isDirty } = useForm({ ... })

{isDirty && <div>保存されていない変更があります。</div>}
```

```svelte Svelte icon="s"
{#if $form.isDirty}
    <div>保存されていない変更があります。</div>
{/if}
```

</CodeGroup>

### フォーム送信のキャンセル

フォーム送信をキャンセルするには、`cancel()` メソッドを使用します。

<CodeGroup>

```js Vue icon="vuejs"
form.cancel()
```

```js React icon="react"
const { cancel } = useForm({ ... })

cancel()
```

```js Svelte icon="s"
$form.cancel()
```

</CodeGroup>

### フォームデータと履歴状態

Inertia にフォームのデータやエラーを [履歴状態](/v2/data-props/remembering-state) に保存させるには、フォーム生成時に一意のキーを最初の引数として渡します。

<CodeGroup>

```js Vue icon="vuejs"
import { useForm } from '@inertiajs/vue3'

const form = useForm('CreateUser', data)
const form = useForm(`EditUser:${user.id}`)
```

```js React icon="react"
import { useForm } from '@inertiajs/react'

const form = useForm('CreateUser', data)
const form = useForm(`EditUser:${user.id}`)
```

```js Svelte icon="s"
import { useForm } from '@inertiajs/svelte'

const form = useForm('CreateUser', data)
const form = useForm(`EditUser:${user.id}`)
```

</CodeGroup>

#### フィールドの除外

場合によっては、特定のフィールドを履歴状態に保存しないようにしたいことがあります。たとえば、セキュリティ上の理由でパスワードフィールドを除外することができます。

<CodeGroup>

```js Vue icon="vuejs"
import { useForm } from '@inertiajs/vue3'

const form = useForm('LoginForm', {
    email: '',
    password: '',
}).dontRemember('password')
```

```js React icon="react"
import { useForm } from '@inertiajs/react'

const form = useForm('LoginForm', {
    email: '',
    password: '',
}).dontRemember('password')
```

```js Svelte icon="s"
import { useForm } from '@inertiajs/svelte'

const form = useForm('LoginForm', {
    email: '',
    password: '',
}).dontRemember('password')
```

</CodeGroup>

複数のフィールドを除外する場合は、追加の引数として渡します。

```js
form.dontRemember('password', 'password_confirmation')
```

<Note>
一部のブラウザでは、パスワードフィールドの値が履歴状態に書き込まれると、フォーム送信がなくても「パスワードを保存しますか？」というプロンプトが表示されることがあります。パスワードフィールドを除外することでこの問題を回避できます。
</Note>

### Wayfinder

<Badge>v2.0.6+</Badge>

[Wayfinder](https://github.com/laravel/wayfinder) をフォームヘルパーと併用する場合、生成されたオブジェクトを直接 `form.submit` に渡すだけで、HTTP メソッドや URL が自動的に推測されます。

<CodeGroup>

```js Vue icon="vuejs"
import { useForm } from '@inertiajs/vue3'
import { store } from 'App/Http/Controllers/UserController'

const form = useForm({
    name: 'John Doe',
    email: 'john.doe@example.com',
})

form.submit(store())
```

```js React icon="react"
import { useForm } from '@inertiajs/react'
import { store } from 'App/Http/Controllers/UserController'

const form = useForm({
    name: 'John Doe',
    email: 'john.doe@example.com',
})

form.submit(store())
```

```js Svelte icon="s"
import { useForm } from '@inertiajs/svelte'
import { store } from 'App/Http/Controllers/UserController'

const form = useForm({
    name: 'John Doe',
    email: 'john.doe@example.com',
})

form.submit(store())
```

</CodeGroup>

### Precognition

<Badge>v2.3+</Badge>

`<Form>` コンポーネントと同様に、`useForm` ヘルパーはリアルタイムバリデーションの [Precognition](#precognition) に対応しています。HTTP メソッドとバリデーション用エンドポイントを指定して `withPrecognition()` をチェーンすることで有効化できます。

<Note>
Precognition はサーバーサイドの対応が必要です。Laravel の場合は [Laravel Precognition ドキュメント](https://laravel.com/docs/precognition) を参照してください。他のフレームワークの場合は [プロトコルページ](/v2/core-concepts/the-protocol#request-headers) を参照してください。
</Note>

<CodeGroup>

```js Vue icon="vuejs"
import { useForm } from '@inertiajs/vue3'

const form = useForm({
    name: '',
    email: '',
}).withPrecognition('post', '/users')
```

```js React icon="react"
import { useForm } from '@inertiajs/react'

const form = useForm({
    name: '',
    email: '',
}).withPrecognition('post', '/users')
```

```js Svelte icon="s"
import { useForm } from '@inertiajs/svelte'

const form = useForm({
    name: '',
    email: '',
}).withPrecognition('post', '/users')
```

</CodeGroup>

互換性のため、`laravel-precognition` パッケージと同様に、最初の引数にメソッドと URL を渡すこともできます。

```js
const form = useForm('post', '/users', {
    name: '',
    email: '',
})
```

<Tip>
Precognition は現在組み込み済みのため、`laravel-precognition` パッケージを削除し、Inertia アダプターから `useForm` をインポートしてください。
</Tip>

Wayfinder と組み合わせて Precognition を使用することも可能です。

```js
import { store } from 'App/Http/Controllers/UserController'

const form = useForm({
    name: '',
    email: '',
}).withPrecognition(store())

// または Wayfinder を最初の引数として渡す...
const form = useForm(store(), {
    name: '',
    email: '',
})
```

Precognition を有効化したら、特定のフィールドのバリデーションを実行するには `validate()` を呼び出します。`invalid()` ヘルパーでエラーの有無を確認でき、`validating` はリクエスト進行中を示します。

<CodeGroup>

```vue Vue icon="vuejs"
<script setup>
import { useForm } from '@inertiajs/vue3'

const form = useForm('post', '/users', {
    name: '',
    email: '',
})
</script>

<template>
    <form @submit.prevent="form.post('/users')">
        <input v-model="form.name" @change="form.validate('name')" />
        <p v-if="form.invalid('name')">{{ form.errors.name }}</p>

        <input v-model="form.email" @change="form.validate('email')" />
        <p v-if="form.invalid('email')">{{ form.errors.email }}</p>

        <p v-if="form.validating">Validating...</p>

        <button type="submit">ユーザー作成</button>
    </form>
</template>
```

```jsx React icon="react"
import { useForm } from '@inertiajs/react'

const { data, setData, post, errors, validating, validate, invalid } = useForm('post', '/users', {
    name: '',
    email: '',
})

function submit(e) {
    e.preventDefault()
    post('/users')
}

return (
    <form onSubmit={submit}>
        <input value={data.name} onChange={e => setData('name', e.target.value)} onBlur={() => validate('name')} />
        {invalid('name') && <p>{errors.name}</p>}

        <input value={data.email} onChange={e => setData('email', e.target.value)} onBlur={() => validate('email')} />
        {invalid('email') && <p>{errors.email}</p>}

        {validating && <p>Validating...</p>}

        <button type="submit">ユーザー作成</button>
    </form>
)
```

```svelte Svelte icon="s"
<script>
import { useForm } from '@inertiajs/svelte'

const form = useForm('post', '/users', {
    name: '',
    email: '',
})
</script>

<form on:submit|preventDefault={() => $form.post('/users')}>
    <input bind:value={$form.name} on:change={() => $form.validate('name')} />
    {#if $form.invalid('name')}
        <p>{$form.errors.name}</p>
    {/if}

    <input bind:value={$form.email} on:change={() => $form.validate('email')} />
    {#if $form.invalid('email')}
        <p>{$form.errors.email}</p>
    {/if}

    {#if $form.validating}
        <p>Validating...</p>
    {/if}

    <button type="submit">ユーザー作成</button>
</form>
```

</CodeGroup>

`valid()` ヘルパーで、フィールドがバリデーションを通過しているか確認できます。

#### タッチとバリデーション

`touch()` メソッドでフィールドを「タッチ済み」とマークできます（バリデーションは発生しません）。その後、引数なしで `validate()` を呼び出すと、タッチ済みフィールドすべてをバリデートできます。`touched()` ヘルパーでフィールドがタッチ済みか確認でき、`reset()` でタッチ状態をリセットします。

<CodeGroup>

```vue Vue icon="vuejs"
<input v-model="form.name" @blur="form.touch('name')" />
<input v-model="form.email" @blur="form.touch('email')" />

<button type="button" @click="form.validate()">タッチ済みフィールドをバリデート</button>

<p v-if="form.touched('name')">名前がタッチされました</p>
```

```jsx React icon="react"
<input value={data.name} onChange={e => setData('name', e.target.value)} onBlur={() => touch('name')} />
<input value={data.email} onChange={e => setData('email', e.target.value)} onBlur={() => touch('email')} />

<button type="button" onClick={() => validate()}>タッチ済みフィールドをバリデート</button>

{touched('name') && <p>名前がタッチされました</p>}
```

```svelte Svelte icon="s"
<input bind:value={$form.name} on:blur={() => $form.touch('name')} />
<input bind:value={$form.email} on:blur={() => $form.touch('email')} />

<button type="button" on:click={() => $form.validate()}>タッチ済みフィールドをバリデート</button>

{#if $form.touched('name')}
    <p>名前がタッチされました</p>
{/if}
```

</CodeGroup>

#### オプション

バリデーションリクエストは自動でデバウンスされます。最初のリクエストは即座に実行され、その後の変更はデフォルトで 1500ms デバウンスされます。`setValidationTimeout()` でこのタイムアウトを変更可能です。

<CodeGroup>

```js Vue icon="vuejs"
const form = useForm('post', '/users', {
    name: '',
}).setValidationTimeout(500)
```

```js React icon="react"
const form = useForm('post', '/users', {
    name: '',
})

form.setValidationTimeout(500)
```

```js Svelte icon="s"
const form = useForm('post', '/users', {
    name: '',
})

$form.setValidationTimeout(500)
```

</CodeGroup>

デフォルトではファイルはバリデーションリクエストから除外され、不要なアップロードを防ぎます。`validateFiles()` を使うことでファイルバリデーションを有効化できます。

<CodeGroup>

```js Vue icon="vuejs"
const form = useForm('post', '/users', {
    avatar: null,
}).validateFiles()
```

```js React icon="react"
const form = useForm('post', '/users', {
    avatar: null,
})

form.validateFiles()
```

```js Svelte icon="s"
const form = useForm('post', '/users', {
    avatar: null,
})

$form.validateFiles()
```

</CodeGroup>

デフォルトでは、バリデーションエラーは文字列（最初のエラーメッセージ）のみ簡略化されます。`withAllErrors()` を使うと、すべてのエラーを配列として取得可能です。

<CodeGroup>

```js Vue icon="vuejs"
const form = useForm('post', '/users', {
    name: '',
}).withAllErrors()
```

```js React icon="react"
const form = useForm('post', '/users', {
    name: '',
})

form.withAllErrors()
```

```js Svelte icon="s"
const form = useForm('post', '/users', {
    name: '',
})

$form.withAllErrors()
```

</CodeGroup>

Precognition が有効な場合、`submit()` を引数なしで呼び出すと、設定されたエンドポイントに送信されます。

## サーバーサイドのレスポンス

Inertia を使う場合、従来の XHR や fetch のようにクライアント側でフォームレスポンスを直接確認することはほとんどありません。代わりに、サーバーサイドのルートやコントローラーでフォーム処理後に [リダイレクト](/v2/the-basics/redirects) を返すのが一般的です。

```php
class UsersController extends Controller
{
    public function index()
    {
        return Inertia::render('Users/Index', [
            'users' => User::all(),
        ]);
    }

    public function store(Request $request)
    {
        User::create($request->validate([
            'first_name' => ['required', 'max:50'],
            'last_name' => ['required', 'max:50'],
            'email' => ['required', 'max:50', 'email'],
        ]));

        return to_route('users.index');
    }
}
```

このリダイレクトベースのアプローチは、`<Form>` コンポーネント、`useForm` ヘルパー、手動ルーター送信のすべてで機能します。Inertia のフォーム処理を従来のサーバーサイドフォーム送信と同じ感覚で扱えます。

## サーバーサイドバリデーション

`<Form>` コンポーネントや `useForm` ヘルパーは、サーバーサイドのバリデーションエラーを自動で処理します。サーバーがバリデーションエラーを返すと、追加の設定なしで `errors` オブジェクトで利用可能になります。

従来の XHR や fetch リクエストで `422` ステータスコードをチェックする必要がある場合とは異なり、Inertia はバリデーションエラーをリダイレクトベースのフローの一部として処理します。これは従来のサーバーサイドフォーム送信と同じですが、ページ全体のリロードは発生しません。

エラーバッグや高度なシナリオを含むバリデーションエラーの完全なガイドは、[バリデーションのドキュメント](/v2/the-basics/validation)をご覧ください。

## 手動フォーム送信

`<Form>` コンポーネントや `useForm` ヘルパーを使わずに、Inertia の `router` メソッドを直接使ってフォームを手動で送信することも可能です。

<CodeGroup>

```vue Vue icon="vuejs"
<script setup>
import { reactive } from 'vue'
import { router } from '@inertiajs/vue3'

const form = reactive({
    first_name: null,
    last_name: null,
    email: null,
})

function submit() {
    router.post('/users', form)
}
</script>

<template>
    <form @submit.prevent="submit">
        <label for="first_name">First name:</label>
        <input id="first_name" v-model="form.first_name" />
        <label for="last_name">Last name:</label>
        <input id="last_name" v-model="form.last_name" />
        <label for="email">Email:</label>
        <input id="email" v-model="form.email" />
        <button type="submit">Submit</button>
    </form>
</template>
```

```jsx React icon="react"
import { useState } from 'react'
import { router } from '@inertiajs/react'

export default function Edit() {
    const [values, setValues] = useState({
        first_name: "",
        last_name: "",
        email: "",
    })

    function handleChange(e) {
        const key = e.target.id;
        const value = e.target.value
        setValues(values => ({
                ...values,
                [key]: value,
        }))
    }

    function handleSubmit(e) {
        e.preventDefault()
        router.post('/users', values)
    }

    return (
        <form onSubmit={handleSubmit}>
            <label htmlFor="first_name">First name:</label>
            <input id="first_name" value={values.first_name} onChange={handleChange} />
            <label htmlFor="last_name">Last name:</label>
            <input id="last_name" value={values.last_name} onChange={handleChange} />
            <label htmlFor="email">Email:</label>
            <input id="email" value={values.email} onChange={handleChange} />
            <button type="submit">Submit</button>
        </form>
    )
}
```

```svelte Svelte 4 icon="s"
<script>
import { router } from '@inertiajs/svelte'

let values = {
    first_name: null,
    last_name: null,
    email: null,
}

function submit() {
    router.post('/users', values)
}
</script>

<form on:submit|preventDefault={submit}>
    <label for="first_name">First name:</label>
    <input id="first_name" bind:value={values.first_name}>

    <label for="last_name">Last name:</label>
    <input id="last_name" bind:value={values.last_name}>

    <label for="email">Email:</label>
    <input id="email" bind:value={values.email}>

    <button type="submit">Submit</button>
</form>
```

```svelte Svelte 5 icon="s"
<script>
import { router } from '@inertiajs/svelte'

let values = {
    first_name: null,
    last_name: null,
    email: null,
}

function submit(e) {
    e.preventDefault()
    router.post('/users', values)
}
</script>

<form onsubmit={submit}>
    <label for="first_name">First name:</label>
    <input id="first_name" bind:value={values.first_name}>

    <label for="last_name">Last name:</label>
    <input id="last_name" bind:value={values.last_name}>

    <label for="email">Email:</label>
    <input id="email" bind:value={values.email}>

    <button type="submit">Submit</button>
</form>
```

</CodeGroup>

## ファイルアップロード

ファイルを含むリクエストやフォーム送信を行う場合、Inertia は自動的に送信データを `FormData` オブジェクトに変換します。これは `<Form>` コンポーネント、`useForm` ヘルパー、手動の router 送信すべてで機能します。

進行状況の追跡を含むファイルアップロードの詳細は、[ファイルアップロードのドキュメント](/v2/the-basics/file-uploads)をご覧ください。

## XHR / Fetch 送信

Inertia を使ったフォーム送信はほとんどの状況で問題なく動作します。しかし、フォーム送信の制御をより細かく行いたい場合は、従来の XHR や `fetch` を使って好きなライブラリで送信することも可能です。
